"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TenderlyService = void 0;
const constants_1 = require("../../../common/constants");
const errors_1 = require("../common/errors");
const logger_1 = require("../../../utils/logger");
const log_compliance_1 = require("../../../utils/log-compliance");
const TenderlyApiService_1 = require("./TenderlyApiService");
class TenderlyService {
    constructor(pluginName) {
        this.pluginName = pluginName;
    }
    async getNetworks() {
        logger_1.logger.debug("Obtaining public networks.");
        let tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureAnonymousInstance();
        if (TenderlyApiService_1.TenderlyApiService.isAuthenticated()) {
            tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureInstance();
        }
        try {
            const res = await tenderlyApi.get("/api/v1/public-networks");
            if (res.data === undefined || res.data === null) {
                logger_1.logger.error("There was an error while obtaining public networks from Tenderly. Obtained response is invalid.");
                return [];
            }
            const logCompliantNetworks = (0, log_compliance_1.convertToLogCompliantNetworks)(res.data);
            logger_1.logger.silly("Obtained public networks:", logCompliantNetworks);
            return res.data;
        }
        catch (err) {
            const logCompliantApiErr = (0, log_compliance_1.convertToLogCompliantApiError)(err);
            logger_1.logger.error(logCompliantApiErr);
            console.log(`Error in ${this.pluginName}: ${errors_1.NETWORK_FETCH_FAILED_ERR_MSG}`);
        }
        return [];
    }
    async getLatestBlockNumber(networkId) {
        logger_1.logger.debug("Getting latest block number.");
        let tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureAnonymousInstance();
        if (TenderlyApiService_1.TenderlyApiService.isAuthenticated()) {
            tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureInstance();
        }
        try {
            const res = await tenderlyApi.get(`/api/v1/network/${networkId}/block-number`);
            if (res.data === undefined || res.data === null) {
                logger_1.logger.error("There was an error while obtaining latest block number from Tenderly. Obtained response is invalid.");
                return null;
            }
            logger_1.logger.trace(`Api successfully returned: ${res.data.block_number}`);
            return res.data.block_number;
        }
        catch (err) {
            const logCompliantApiErr = (0, log_compliance_1.convertToLogCompliantApiError)(err);
            logger_1.logger.error(logCompliantApiErr);
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.LATEST_BLOCK_NUMBER_FETCH_FAILED_ERR_MSG}`);
        }
        return null;
    }
    async verifyContracts(request) {
        logger_1.logger.debug("Verifying contracts publicly.");
        let tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureAnonymousInstance();
        if (TenderlyApiService_1.TenderlyApiService.isAuthenticated()) {
            tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureInstance();
        }
        try {
            if (request.contracts.length === 0) {
                logger_1.logger.error(errors_1.NO_VERIFIABLE_CONTRACTS_ERR_MSG);
                return;
            }
            const res = await tenderlyApi.post("/api/v1/public/verify-contracts", { ...request });
            if (res.data === undefined || res.data === null) {
                logger_1.logger.error("There was an error while publicly verifying contracts on Tenderly. Obtained response is invalid.");
                return;
            }
            const logCompliantVerificationResponse = (0, log_compliance_1.convertToLogCompliantVerificationResponse)(res.data);
            logger_1.logger.trace("Verification response:", logCompliantVerificationResponse);
            const responseData = res.data;
            if (responseData.bytecode_mismatch_errors !== null) {
                logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.BYTECODE_MISMATCH_ERR_MSG}`);
                return;
            }
            if (responseData.contracts === undefined || responseData.contracts === null) {
                logger_1.logger.error("There was an error during public verification. There are no returned contracts.");
                return;
            }
            if (responseData.contracts.length === 0) {
                let addresses = "";
                for (const cont of request.contracts) {
                    addresses += `${cont.contractName}, `;
                }
                logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.NO_NEW_CONTRACTS_VERIFIED_ERR_MSG}`, addresses);
                return;
            }
            console.log("Smart Contracts successfully verified");
            console.group();
            for (const contract of responseData.contracts) {
                const contractLink = `${constants_1.TENDERLY_DASHBOARD_BASE_URL}/contract/${constants_1.CHAIN_ID_NETWORK_NAME_MAP[contract.network_id]}/${contract.address}`;
                console.log(`Contract ${contract.address} verified. You can view the contract at ${contractLink}`);
            }
            console.groupEnd();
        }
        catch (err) {
            const logCompliantApiError = (0, log_compliance_1.convertToLogCompliantApiError)(err);
            logger_1.logger.error(logCompliantApiError);
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.API_VERIFICATION_REQUEST_ERR_MSG}`);
        }
    }
    async pushContracts(request, tenderlyProject, username) {
        logger_1.logger.debug("Pushing contracts onto Tenderly.");
        if (!TenderlyApiService_1.TenderlyApiService.isAuthenticated()) {
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.ACCESS_TOKEN_NOT_PROVIDED_ERR_MSG}`);
            return;
        }
        const tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureInstance();
        try {
            const res = await tenderlyApi.post(`/api/v1/account/${username}/project/${tenderlyProject}/contracts`, {
                ...request,
            });
            if (res.data === undefined || res.data === null) {
                logger_1.logger.error("There was an error while pushing contracts to Tenderly. Obtained response is invalid.");
                return;
            }
            const logCompliantVerificationResponse = (0, log_compliance_1.convertToLogCompliantVerificationResponse)(res.data);
            logger_1.logger.trace("Verification response:", logCompliantVerificationResponse);
            const responseData = res.data;
            if (responseData.bytecode_mismatch_errors !== null) {
                logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.BYTECODE_MISMATCH_ERR_MSG}`);
                return;
            }
            if (responseData.contracts.length === 0) {
                let addresses = "";
                for (const cont of request.contracts) {
                    addresses += `${cont.contractName}, `;
                }
                logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.NO_NEW_CONTRACTS_VERIFIED_ERR_MSG}`, addresses);
                return;
            }
            const dashLink = `${constants_1.TENDERLY_DASHBOARD_BASE_URL}/${username}/${tenderlyProject}/contracts`;
            console.log(`Successfully privately verified Smart Contracts for project ${tenderlyProject}. You can view your contracts at ${dashLink}`);
        }
        catch (err) {
            const logCompliantApiError = (0, log_compliance_1.convertToLogCompliantApiError)(err);
            logger_1.logger.error(logCompliantApiError);
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.API_VERIFICATION_REQUEST_ERR_MSG}`);
        }
    }
    async verifyContractsMultiCompiler(request) {
        logger_1.logger.debug("Publicly verifying contracts on tenderly. (Multi compiler version)");
        let tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureAnonymousInstance();
        if (TenderlyApiService_1.TenderlyApiService.isAuthenticated()) {
            tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureInstance();
        }
        try {
            if (request.contracts.length === 0) {
                logger_1.logger.error(errors_1.NO_VERIFIABLE_CONTRACTS_ERR_MSG);
                return;
            }
            const res = await tenderlyApi.post("/api/v1/public/contracts/verify", { ...request });
            if (res.data === undefined || res.data === null) {
                logger_1.logger.error("There was an error while publicly verifying contracts on Tenderly. Obtained response is invalid.");
                return;
            }
            const response = (0, log_compliance_1.convertToLogCompliantVerificationResponse)(res.data);
            logger_1.logger.trace("Verification response:", response);
            if (response.compilation_errors !== undefined && response.compilation_errors !== null) {
                logger_1.logger.error("There have been compilation errors while verifying contracts.", response.compilation_errors);
                return;
            }
            if (response.results === undefined || response.results === null) {
                logger_1.logger.error("There has been an error while verifying contracts, no verified contracts nor bytecode mismatch errors are returned.");
                return;
            }
            if (response.results.bytecode_mismatch_errors !== undefined &&
                response.results.bytecode_mismatch_errors !== null) {
                for (const bytecodeMismatchError of response.results.bytecode_mismatch_errors) {
                    logger_1.logger.error("There has been a bytecode mismatch error while verifying contract.", bytecodeMismatchError);
                }
            }
            if (response.results.verified_contracts !== undefined && response.results.verified_contracts !== null) {
                for (const verifiedContract of response.results.verified_contracts) {
                    const contractLink = `${constants_1.TENDERLY_DASHBOARD_BASE_URL}/contract/${constants_1.CHAIN_ID_NETWORK_NAME_MAP[verifiedContract.network_id]}/${verifiedContract.address}`;
                    const logMsg = `Contract ${verifiedContract.address} verified. You can view the contract at ${contractLink}`;
                    console.log(logMsg);
                    logger_1.logger.trace(logMsg);
                }
            }
        }
        catch (err) {
            const logCompliantApiError = (0, log_compliance_1.convertToLogCompliantApiError)(err);
            logger_1.logger.error(logCompliantApiError);
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.API_VERIFICATION_REQUEST_ERR_MSG}`);
        }
    }
    async pushContractsMultiCompiler(request, tenderlyProject, username) {
        logger_1.logger.debug("Privately verifying contracts on tenderly. (Multi compiler version)");
        if (!TenderlyApiService_1.TenderlyApiService.isAuthenticated()) {
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.ACCESS_TOKEN_NOT_PROVIDED_ERR_MSG}`);
            return;
        }
        const tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureInstance();
        try {
            if (request.contracts.length === 0) {
                logger_1.logger.error(errors_1.NO_VERIFIABLE_CONTRACTS_ERR_MSG);
                return;
            }
            const res = await tenderlyApi.post(`/api/v1/accounts/${username}/projects/${tenderlyProject}/contracts/verify`, {
                ...request,
            });
            if (res.data === undefined || res.data === null) {
                logger_1.logger.error("There was an error while privately verifying contracts on Tenderly. Obtained response is invalid.");
                return;
            }
            const response = (0, log_compliance_1.convertToLogCompliantVerificationResponse)(res.data);
            logger_1.logger.trace("Verification response:", response);
            if (response.compilation_errors !== undefined && response.compilation_errors !== null) {
                logger_1.logger.error("There have been compilation errors while verifying contracts.", response.compilation_errors);
                return;
            }
            if (response.results === undefined || response.results === null) {
                logger_1.logger.error("There has been an error while verifying contracts, no verified contracts nor bytecode mismatch errors are returned.");
                return;
            }
            if (response.results.bytecode_mismatch_errors !== undefined &&
                response.results.bytecode_mismatch_errors !== null) {
                for (const bytecodeMismatchError of response.results.bytecode_mismatch_errors) {
                    logger_1.logger.error("There has been a bytecode mismatch error while verifying contract.", bytecodeMismatchError);
                }
            }
            if (response.results.verified_contracts !== undefined && response.results.verified_contracts !== null) {
                for (const verifiedContract of response.results.verified_contracts) {
                    await this.addContractToProject(username, tenderlyProject, {
                        network_id: verifiedContract.network_id,
                        address: verifiedContract.address,
                        display_name: verifiedContract.contract_name,
                        unverified: false,
                    });
                }
                for (const verifiedContract of response.results.verified_contracts) {
                    const contractLink = `${constants_1.TENDERLY_DASHBOARD_BASE_URL}/${username}/${tenderlyProject}/contract/${constants_1.CHAIN_ID_NETWORK_NAME_MAP[verifiedContract.network_id]}/${verifiedContract.address}`;
                    const logMsg = `Contract ${verifiedContract.address} verified. You can view the contract at ${contractLink}`;
                    console.log(logMsg);
                    logger_1.logger.trace(logMsg);
                }
            }
        }
        catch (err) {
            const logCompliantApiError = (0, log_compliance_1.convertToLogCompliantApiError)(err);
            logger_1.logger.error(logCompliantApiError);
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.API_VERIFICATION_REQUEST_ERR_MSG}`);
        }
    }
    async verifyForkContracts(request, tenderlyProject, username, fork) {
        logger_1.logger.info("Verifying contracts on fork.");
        if (!TenderlyApiService_1.TenderlyApiService.isAuthenticated()) {
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.ACCESS_TOKEN_NOT_PROVIDED_ERR_MSG}`);
            return;
        }
        const tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureTenderlyRPCInstance();
        try {
            const res = await tenderlyApi.post(`/account/${username}/project/${tenderlyProject}/fork/${fork}/verify`, {
                ...request,
            });
            if (res.data === undefined || res.data === null) {
                logger_1.logger.error("There was an error while verifying contracts on fork. Obtained response is invalid.");
            }
            const logCompliantVerificationResponse = (0, log_compliance_1.convertToLogCompliantForkVerificationResponse)(res.data);
            logger_1.logger.trace("Verification response:", logCompliantVerificationResponse);
            const responseData = res.data;
            if (responseData.bytecode_mismatch_errors !== null) {
                logger_1.logger.error(errors_1.BYTECODE_MISMATCH_ERR_MSG);
                return;
            }
            if (responseData.contracts.length === 0) {
                let addresses = "";
                for (const cont of request.contracts) {
                    addresses += `${cont.contractName}, `;
                }
                logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.NO_NEW_CONTRACTS_VERIFIED_ERR_MSG}`, addresses);
                return;
            }
            console.group();
            for (const contract of responseData.contracts) {
                console.log(`Contract at ${contract.address} verified.`);
            }
            console.groupEnd();
        }
        catch (err) {
            const logCompliantApiError = (0, log_compliance_1.convertToLogCompliantApiError)(err);
            logger_1.logger.error(logCompliantApiError);
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.API_VERIFICATION_REQUEST_ERR_MSG}`);
        }
    }
    async verifyForkContractsMultiCompiler(request, tenderlyProject, username, forkID) {
        logger_1.logger.info("Verifying contracts on fork. (Multi compiler version)");
        if (!TenderlyApiService_1.TenderlyApiService.isAuthenticated()) {
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.ACCESS_TOKEN_NOT_PROVIDED_ERR_MSG}`);
            return;
        }
        const tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureInstance();
        try {
            const res = await tenderlyApi.post(`api/v1/account/${username}/project/${tenderlyProject}/fork/${forkID}/contracts/verify`, { ...request });
            if (res.data === undefined || res.data === null) {
                logger_1.logger.error("There was an error while verifying contracts on fork (Multi compiler version). Obtained response is invalid.");
            }
            const response = (0, log_compliance_1.convertToLogCompliantVerificationResponse)(res.data);
            logger_1.logger.trace("Verification response:", response);
            if (response.compilation_errors !== undefined && response.compilation_errors !== null) {
                logger_1.logger.error("There have been compilation errors while verifying contracts.", response.compilation_errors);
                return;
            }
            if (response.results === undefined || response.results === null) {
                logger_1.logger.error("There has been an error while verifying contracts, no verified contracts nor bytecode mismatch errors are returned.");
                return;
            }
            if (response.results.bytecode_mismatch_errors !== undefined &&
                response.results.bytecode_mismatch_errors !== null) {
                for (const bytecodeMismatchError of response.results.bytecode_mismatch_errors) {
                    logger_1.logger.error("There has been a bytecode mismatch error while verifying contract.", bytecodeMismatchError);
                }
            }
            if (response.results.verified_contracts !== undefined && response.results.verified_contracts !== null) {
                for (const verifiedContract of response.results.verified_contracts) {
                    const contractLink = `${constants_1.TENDERLY_DASHBOARD_BASE_URL}/${username}/${tenderlyProject}/fork/${forkID}`;
                    const logMsg = `Contract ${verifiedContract.address} verified. You can view the contract at the fork: ${contractLink}`;
                    console.log(logMsg);
                    logger_1.logger.trace(logMsg);
                }
            }
        }
        catch (err) {
            const logCompliantApiError = (0, log_compliance_1.convertToLogCompliantApiError)(err);
            logger_1.logger.error(logCompliantApiError);
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.API_VERIFICATION_REQUEST_ERR_MSG}`);
        }
    }
    async addContractToProject(username, project, request) {
        logger_1.logger.debug("Bulk adding contracts to project:", project);
        if (!TenderlyApiService_1.TenderlyApiService.isAuthenticated()) {
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.ACCESS_TOKEN_NOT_PROVIDED_ERR_MSG}`);
            return;
        }
        const tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureInstance();
        try {
            const res = await tenderlyApi.post(`/api/v1/account/${username}/project/${project}/address`, { ...request });
            if (res.status !== 200) {
                logger_1.logger.error(`There was an error while adding contracts to project. Status is ${res.status}`);
                return;
            }
            logger_1.logger.debug(`Added contract to project '${project}' successfully.`);
        }
        catch (err) {
            const logCompliantApiError = (0, log_compliance_1.convertToLogCompliantApiError)(err);
            logger_1.logger.error(logCompliantApiError);
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.API_ADD_CONTRACT_REQUEST_ERR_MSG}`);
        }
    }
    async getPrincipal() {
        logger_1.logger.debug("Getting principal.");
        if (!TenderlyApiService_1.TenderlyApiService.isAuthenticated()) {
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.ACCESS_TOKEN_NOT_PROVIDED_ERR_MSG}`);
            return null;
        }
        const tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureInstance();
        try {
            const res = await tenderlyApi.get("/api/v1/user");
            if (res.data === undefined || res.data === null) {
                logger_1.logger.error("There was an error while obtaining principal from Tenderly. Obtained response is invalid.");
            }
            logger_1.logger.trace("Retrieved data:", { id: res.data.user.id });
            return {
                id: res.data.user.id,
                username: res.data.user.username,
            };
        }
        catch (err) {
            const logCompliantApiError = (0, log_compliance_1.convertToLogCompliantApiError)(err);
            logger_1.logger.error(logCompliantApiError);
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.PRINCIPAL_FETCH_FAILED_ERR_MSG}`);
        }
        return null;
    }
    async getProjectSlugs(principalId) {
        logger_1.logger.debug("Getting project slugs.");
        if (!TenderlyApiService_1.TenderlyApiService.isAuthenticated()) {
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.ACCESS_TOKEN_NOT_PROVIDED_ERR_MSG}`);
            return [];
        }
        const tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureInstance();
        try {
            const res = await tenderlyApi.get(`/api/v1/account/${principalId}/projects`);
            if (res.data === undefined || res.data === null) {
                logger_1.logger.error("There was an error while obtaining project slug from Tenderly. Obtained response is invalid.");
            }
            const logCompliantProjects = (0, log_compliance_1.convertToLogCompliantProjects)(res.data.projects);
            logger_1.logger.trace("Obtained projects:", logCompliantProjects);
            return res.data.projects;
        }
        catch (err) {
            const logCompliantApiError = (0, log_compliance_1.convertToLogCompliantApiError)(err);
            logger_1.logger.error(logCompliantApiError);
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.PROJECTS_FETCH_FAILED_ERR_MSG}`);
        }
        return [];
    }
    async verifyDevnetContractsMultiCompiler(request, tenderlyProject, username, devnetID, accessKey) {
        logger_1.logger.info("Verifying contracts on devnet. (Multi compiler version)");
        if (!accessKey && !TenderlyApiService_1.TenderlyApiService.isAuthenticated()) {
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.ACCESS_TOKEN_NOT_PROVIDED_ERR_MSG}`);
            return;
        }
        const tenderlyApi = TenderlyApiService_1.TenderlyApiService.configureInstance(accessKey);
        try {
            const res = await tenderlyApi.post(`api/v1/account/${username}/project/${tenderlyProject}/devnet/endpoint/${devnetID}/contracts/verify`, { ...request });
            if (res.data === undefined || res.data === null) {
                logger_1.logger.error("There was an error while verifying contracts on devnet (Multi compiler version). Obtained response is invalid.");
            }
            const response = (0, log_compliance_1.convertToLogCompliantVerificationResponse)(res.data);
            logger_1.logger.trace("Verification response:", response);
            if (response.compilation_errors !== undefined && response.compilation_errors !== null) {
                logger_1.logger.error("There have been compilation errors while verifying contracts.", response.compilation_errors);
                return;
            }
            if (response.results === undefined || response.results === null) {
                logger_1.logger.error("There has been an error while verifying contracts, no verified contracts nor bytecode mismatch errors are returned.");
                return;
            }
            if (response.results.bytecode_mismatch_errors !== undefined &&
                response.results.bytecode_mismatch_errors !== null) {
                for (const bytecodeMismatchError of response.results.bytecode_mismatch_errors) {
                    logger_1.logger.error("There has been a bytecode mismatch error while verifying contract.", bytecodeMismatchError);
                }
            }
            if (response.results.verified_contracts !== undefined && response.results.verified_contracts !== null) {
                for (const verifiedContract of response.results.verified_contracts) {
                    const contractLink = response.display_link;
                    const logMsg = `Contract ${verifiedContract.address} verified. You can view the contract at the devnet: ${contractLink}`;
                    console.log(logMsg);
                    logger_1.logger.trace(logMsg);
                }
            }
        }
        catch (err) {
            const logCompliantApiError = (0, log_compliance_1.convertToLogCompliantApiError)(err);
            logger_1.logger.error(logCompliantApiError);
            logger_1.logger.error(`Error in ${this.pluginName}: ${errors_1.API_VERIFICATION_REQUEST_ERR_MSG}`);
        }
    }
}
exports.TenderlyService = TenderlyService;
//# sourceMappingURL=TenderlyService.js.map